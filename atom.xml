<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <author>
    <name>OnricYF</name>
  </author>
  <generator uri="https://hexo.io/">Hexo</generator>
  <id>http://example.com/</id>
  <link href="http://example.com/" rel="alternate"/>
  <link href="http://example.com/atom.xml" rel="self"/>
  <rights>All rights reserved 2026, OnricYF</rights>
  <subtitle>xxx</subtitle>
  <title>YF's Blogs</title>
  <updated>2026-02-25T14:13:14.169Z</updated>
  <entry>
    <author>
      <name>OnricYF</name>
    </author>
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    <category term="杂记" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%9D%82%E8%AE%B0/"/>
    <category term="Three.js" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%9D%82%E8%AE%B0/Three-js/"/>
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    <category term="渲染" scheme="http://example.com/tags/%E6%B8%B2%E6%9F%93/"/>
    <content>
      <![CDATA[<h2 id="创建场景"><a href="#创建场景" class="headerlink" title="创建场景"></a>创建场景</h2><p>要使用自定义的Shader，需要先创建好场景（scene）、相机（camera）和渲染器（renderer）。具体流程参考：<br><a href="https://threejs.org/manual/#zh/creating-a-scene">创建场景 - three.js manual</a></p><h2 id="添加Mesh"><a href="#添加Mesh" class="headerlink" title="添加Mesh"></a>添加Mesh</h2><p>可以通过SphereGeometry()、BoxGeometry()等创建预制的模型，也可以通过MeshLoader导入自定义模型。<br>更多接口参考：<br><a href="https://threejs.org/docs/#BoxGeometry">BoxGeometry – three.js docs</a></p><h3 id="定义Geometry"><a href="#定义Geometry" class="headerlink" title="定义Geometry"></a>定义Geometry</h3><p>这里先定义一个球体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Radius = 1.0;</span><br><span class="line">const geometry = new THREE.SphereGeometry(Radius, 128, 64);</span><br></pre></td></tr></table></figure><h3 id="创建材质"><a href="#创建材质" class="headerlink" title="创建材质"></a>创建材质</h3><p>要使这个球体在场景中显示，需要调用Mesh(geo, mat)来创建对应Object并添加到场景中。因此，定义好Geometry之后还需要创建一个材质。</p><p>three.js库提供了多种预制的材质，如：MeshPhongMaterial()、MeshToon Material()。具体参考：<a href="https://threejs.org/docs/#Material">Material – three.js docs</a></p><p>要使用自定义的Shader，需要调用ShaderMaterial()来创建材质，需要传入uniforms和定义的vertexShader、fragmentShader的字符串。原理和UE的材质系统类似，会将这两端字符串插入到TempShader文件进行编译。</p><p>这里可以单独创建个.js文件来写Shader（three.js使用的是GLSL，具体写法不多赘述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const VertexShader = `</span><br><span class="line"></span><br><span class="line">uniform float uRadius;</span><br><span class="line"></span><br><span class="line">varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">varying vec3 vPosition;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line">  vec3 pos = position;</span><br><span class="line">//</span><br><span class="line">// ... ...</span><br><span class="line">//</span><br><span class="line">  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">const FragmentShader = `</span><br><span class="line"></span><br><span class="line">  varying vec2 vUv;</span><br><span class="line"></span><br><span class="line">  uniform float uRadius;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  void main() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // ... ...</span><br><span class="line"></span><br><span class="line">  gl_FragColor = vec4(vec3(color), 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`;</span><br></pre></td></tr></table></figure><p>声名好后就可以通过ShaderMaterial()创建了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Material = new THREE.ShaderMaterial(&#123;</span><br><span class="line"></span><br><span class="line">  uniforms: &#123;</span><br><span class="line"></span><br><span class="line">    uRadius: &#123; value: Radius &#125;,</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  vertexShader: VertexShader,</span><br><span class="line"></span><br><span class="line">  fragmentShader: FragmentShader</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="纹理采样"><a href="#纹理采样" class="headerlink" title="纹理采样"></a>纹理采样</h4><p>要传入纹理，需要先通过TextureLoader()来声名一个纹理加载器，并通过加载器的Load()方法加载纹理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const textureLoader = new THREE.TextureLoader();</span><br><span class="line"></span><br><span class="line">const Texture = textureLoader.load(&#x27;Textures/uv_map_reference.jpg&#x27;);</span><br></pre></td></tr></table></figure><p>加载好后作为uniform传入材质:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Material = new THREE.ShaderMaterial(&#123;</span><br><span class="line"></span><br><span class="line">  uniforms: &#123;</span><br><span class="line"></span><br><span class="line">    uTexture: &#123; value: Texture &#125;,</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  vertexShader: VertexShader,</span><br><span class="line"></span><br><span class="line">  fragmentShader: FragmentShader</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后可以在Shader中通过texture2D()来采样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D uTexture;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">//... ...</span><br><span class="line">vec4 texColor = texture2D(uTexture, vUv);</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建MeshObject"><a href="#创建MeshObject" class="headerlink" title="创建MeshObject"></a>创建MeshObject</h3><p>定义好MeshGeometry信息和材质后，就可以通过Mesh()来创建对应Mesh的Object了，然后通过scene.add(mesh)；添加到场景中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const mesh = new THREE.Mesh(geometry, yinYangMaterial);</span><br><span class="line"></span><br><span class="line">scene.add(mesh);</span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>http://example.com/2026/02/25/ThreeJs/Three.js%20-%20%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84Shader/</id>
    <link href="http://example.com/2026/02/25/ThreeJs/Three.js%20-%20%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84Shader/"/>
    <published>2026-02-25T13:16:14.074Z</published>
    <summary>
      <![CDATA[<h2 id="创建场景"><a href="#创建场景" class="headerlink" title="创建场景"></a>创建场景</h2><p>要使用自定义的Shader，需要先创建好场景（scene）、相机（camera）和渲染器（renderer）。具体流程参考：]]>
    </summary>
    <title>Three.js - 使用自定义的Shader</title>
    <updated>2026-02-25T14:13:14.169Z</updated>
  </entry>
  <entry>
    <author>
      <name>OnricYF</name>
    </author>
    <id>http://example.com/2026/02/25/2026-02-25/</id>
    <link href="http://example.com/2026/02/25/2026-02-25/"/>
    <published>2026-02-25T13:14:59.027Z</published>
    <updated>2026-02-25T13:14:59.027Z</updated>
  </entry>
  <entry>
    <author>
      <name>OnricYF</name>
    </author>
    <category term="图形学" scheme="http://example.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    <content>
      <![CDATA[<h2 id="ThreeJs-学习文档"><a href="#ThreeJs-学习文档" class="headerlink" title="ThreeJs 学习文档"></a>ThreeJs 学习文档</h2><p><a href="https://threejs.org/manual/#zh/creating-a-scene">创建场景 - three.js manual</a></p><h3 id="接口查询"><a href="#接口查询" class="headerlink" title="接口查询"></a>接口查询</h3><p><a href="https://threejs.org/docs/">https://threejs.org/docs/</a></p>]]>
    </content>
    <id>http://example.com/2026/02/23/ThreeJs/ThreejsLearning/</id>
    <link href="http://example.com/2026/02/23/ThreeJs/ThreejsLearning/"/>
    <published>2026-02-23T03:47:06.100Z</published>
    <summary>
      <![CDATA[<h2 id="ThreeJs-学习文档"><a href="#ThreeJs-学习文档" class="headerlink" title="ThreeJs 学习文档"></a>ThreeJs 学习文档</h2><p><a href="https://threejs.org/m]]>
    </summary>
    <title>ThreejsLearning</title>
    <updated>2026-02-23T05:04:39.572Z</updated>
  </entry>
  <entry>
    <author>
      <name>OnricYF</name>
    </author>
    <category term="杂记" scheme="http://example.com/categories/%E6%9D%82%E8%AE%B0/"/>
    <category term="Others" scheme="http://example.com/tags/Others/"/>
    <content>
      <![CDATA[<h2 id="Hexo-基本用法"><a href="#Hexo-基本用法" class="headerlink" title="Hexo 基本用法"></a>Hexo 基本用法</h2><h3 id="添加分类、tag"><a href="#添加分类、tag" class="headerlink" title="添加分类、tag"></a>添加分类、tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags //添加tag</span><br><span class="line"></span><br><span class="line">hexo new page categories //添加分类 </span><br></pre></td></tr></table></figure><h3 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Example Tiltle</span><br><span class="line">categories: [杂记]</span><br><span class="line">tags: [Others]</span><br><span class="line">cover: ## /images/xxx.jpg 封面图片替换##</span><br><span class="line">comments: false</span><br><span class="line">date: 2026-02-22 22:22:10</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="Hexo相关指令"><a href="#Hexo相关指令" class="headerlink" title="Hexo相关指令"></a>Hexo相关指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相关命令`npm install -g hexo-cli`（用 npm 全局安装 Hexo 的命令行工具 hexo-cli，装完就能在任意目录用 `hexo` 命令）</span><br><span class="line"></span><br><span class="line">`hexo init`（在当前目录初始化一个 Hexo 站点：生成基础目录结构和配置文件）</span><br><span class="line">`hexo clean`（清理缓存与已生成文件：通常会删掉 `public/`、`db.json` 之类，解决“生成内容不更新/残留文件”）</span><br><span class="line">`hexo g`（`hexo generate` 的缩写：把 Markdown 等内容生成静态网页到 `public/`）</span><br><span class="line">`hexo s`（`hexo server` 的缩写：启动本地预览服务器，方便在浏览器里看效果）</span><br><span class="line">`hexo d`（`hexo deploy` 的缩写：把生成好的 `public/` 部署/推送到你配置的远端（比如 GitHub Pages））</span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>http://example.com/2026/02/22/Examples/</id>
    <link href="http://example.com/2026/02/22/Examples/"/>
    <published>2026-02-22T14:22:10.000Z</published>
    <summary>
      <![CDATA[<h2 id="Hexo-基本用法"><a href="#Hexo-基本用法" class="headerlink" title="Hexo 基本用法"></a>Hexo 基本用法</h2><h3 id="添加分类、tag"><a href="#添加分类、tag" class="]]>
    </summary>
    <title>Example Tiltle</title>
    <updated>2026-02-23T03:48:45.163Z</updated>
  </entry>
  <entry>
    <author>
      <name>OnricYF</name>
    </author>
    <category term="杂记" scheme="http://example.com/categories/%E6%9D%82%E8%AE%B0/"/>
    <category term="图形学" scheme="http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    <content>
      <![CDATA[<h2 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h2><p>模型(Model)、观察(View)、投影(Projection)</p><h2 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h2><p>局部坐标(Local Coordinate)(模型空间) –&gt; 世界坐标(World Coordinate) –&gt; 观察坐标(View Coordinate) – &gt; 裁剪坐标(Clip Coordinate) –&gt; (NDC空间 [[NDC空间]]) –&gt; 屏幕坐标(Screen Coordinate)<br>![[Pasted image 20221025110600.png]]</p><p>Vertex Shader的输出在Clip Space，那Fragment Shader的输入在什么空间？不是NDC，而是<strong>屏幕空间Screen Space</strong>。<br>Vertex Shader的输出在Clip Space，接着GPU会做透视除法变到NDC。这之后GPU还有一步，应用视口变换，转换到Screen Space，输入给Fragment Shader：</p><p><strong>(Vertex Shader) &#x3D;&gt; Clip Space &#x3D;&gt; (透视除法) &#x3D;&gt; NDC &#x3D;&gt; (视口变换) &#x3D;&gt; Screen Space &#x3D;&gt; (Fragment Shader)</strong></p><h2 id="1-模型空间-Object-Space"><a href="#1-模型空间-Object-Space" class="headerlink" title="1-模型空间(Object Space)"></a>1-模型空间(Object Space)</h2><p><strong>模型空间（model space）<strong>在不同的游戏引擎或者是软件中又称作</strong>对象空间（object space）<strong>或者</strong>局部空间（local space）</strong>。</p><p>在游戏中的每一个模型或者物体都有各自独立的坐标空间，模型有自己的前后左右，这是它的自身属性，旋转或者是移动和缩放模型并不能改变它的前后左右。</p><p>在Unity中，模型空间使用的是左手坐标系，因此在模型空间中，+x轴+y轴+z轴分别对应的是模型的右，上和前向。如下图。</p><p><img src="https://pic3.zhimg.com/80/v2-0b4e65e3d6ba1d0050d3444fbc862d1e_720w.webp"></p><p>九猫：Shader学习（8）各种坐标空间的定义和变换演示</p><h2 id="2-世界空间-World-Space"><a href="#2-世界空间-World-Space" class="headerlink" title="2-世界空间(World Space)"></a>2-世界空间(<strong>World Space</strong>)</h2><p>世界空间是最外层的空间，可以被用于描述绝对位置，这个绝对位置的概念类似于在我们现实世界的经度纬度海拔，</p><p>在渲染中，顶点变换的第一步就是把顶点从模型空间转换到世界空间。空间变换的第一步就是要构建变换矩阵。构建变换矩阵其实就是根据子空间原点在父空间中进行的变换来再对顶点进行一次同样的变换。</p><p><img src="https://pic1.zhimg.com/80/v2-0a51fd63926bff464ac710a272a64af8_720w.webp"></p><p>Transform调整的值也是世界空间</p><h2 id="3-观察空间-View-Space）"><a href="#3-观察空间-View-Space）" class="headerlink" title="3-观察空间**(View Space）**"></a>3-观察空间**(View Space）**</h2><p>观察空间也叫做<strong>摄像机空间（camera space）</strong>。观察空间的原点就是摄像机的位置，摄像机在哪里，观察空间原点就在哪里。</p><p>观察空间中，原点是摄像机位置，+x轴指向右方，+y轴指向上方，+z轴指向后方。<strong>需要注意的是摄像机的前方是-z轴</strong>，因为unity中观察空间使用的是右手坐标系，模型空间和世界空间使用的是左手坐标系，这个只需要记住就行了。</p><p>在渲染流程中，顶点变换的第二步就是把顶点从世界空间变换到观察空间中，这个变换叫做观察变换（view transform） <strong>是MVP变化里的V过程</strong></p><p>相机和物体的运动方向和速度是相同的，我们可以说他们是相对静止的。</p><p>于是我们约定俗称 <strong>假设相机是静止不动的方向永远朝向-z方向，up是Y方向</strong></p><p>所有的物体都可以乘上一个变化矩阵来保持和相机的相对静止；</p><p><img src="https://pic3.zhimg.com/80/v2-b0694b6df838e628ce793756c3fa5e36_720w.webp"></p><p>《GAMES101 现代计算机图形学入门》</p><p><img src="https://pic1.zhimg.com/80/v2-c4b265703e719bf78c720d0c23508be0_720w.webp"></p><p>由平移和旋转组成的变化矩阵《GAMES101 现代计算机图形学入门》</p><h2 id="4-裁剪空间-Clip-Space"><a href="#4-裁剪空间-Clip-Space" class="headerlink" title="4-裁剪空间(Clip Space)"></a><strong>4-裁剪空间(Clip Space)</strong></h2><p>其实就是描述了一个投影范围；范围之外的会被裁剪掉；</p><p><img src="https://pic2.zhimg.com/80/v2-337117dfeef79d5fb3f01b7dc8e69a79_720w.webp"></p><p><img src="https://pic2.zhimg.com/80/v2-cae4a5d213573fb791164a99ba7c1e05_720w.webp"></p><p>透视&#x2F;平行空间《GAMES101 现代计算机图形学入门》</p><p>视锥体的六个平面当中，上下左右四个平面相当于望远镜的镜筒，而近裁剪平面和远裁剪平面则决定了你可以看到的最近和最远的距离。所有位于视锥体之内的物体将会被渲染，否则就会被裁剪而不能进入下一个环节。</p><p>正交投影的视锥体是一个长方体，而透视投影的视锥体是一个四棱锥，<strong>对于透视投影，要想判断顶点是否在一个锥体中是比较麻烦的，所以我们需要先通过一个投影矩阵把顶点转换到一个裁剪空间中。</strong></p><p>任何不满足上述条件的顶点将会被裁剪掉。现在A点的w分量为3.214，很明显不满足条件，所以被裁剪掉了。在Unity中显示的效果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-0eadb4a6eaec44c9c05392c26bfc36b4_720w.webp"></p><p>九猫：Shader学习（8）各种坐标空间的定义和变换演示</p><h2 id="5-屏幕空间-Screen-Space"><a href="#5-屏幕空间-Screen-Space" class="headerlink" title="5-屏幕空间(Screen Space)"></a><strong>5-屏幕空间(Screen Space)</strong></h2><p>这一步就到了对一个顶点进行变换的最后一步，求出顶点在屏幕上的最终位置，也就是把视锥体投影到屏幕空间。</p><p>屏幕空间是一个二维空间，所以我们需要把顶点用齐次除法（homogeneous division）也叫透视除法（perspective division）来把顶点从裁剪空间投影到屏幕空间中。</p><p>齐次除法就是就是用齐次坐标系的w分量去除以x、y、z分量。裁剪空间在经过齐次除法之后，会变换到一个立方体内。</p><p><img src="https://pic4.zhimg.com/80/v2-2543562e40d011a10ac1f724e010960b_720w.webp"></p><p>九猫：Shader学习（8）各种坐标空间的定义和变换演示</p><p><img src="https://pic4.zhimg.com/80/v2-d17720c437dd52e073408e3e2ad359cf_720w.webp"></p><p>《GAMES101 现代计算机图形学入门》</p><p><img src="https://pic2.zhimg.com/80/v2-2d3f5e2829dd981c7f3684cf67d43341_720w.webp"></p><p>《GAMES101 现代计算机图形学入门》</p><p>有一个绝妙的思想，<strong>透视投影 和 水平投影</strong>的差别</p><p><strong>可以理解先把透视投影的 f 宽的那一面 挤压到和 n 那一面一样大</strong></p><p>然后 就是一个水平投影就完事了。</p><p>挤压的过程中 有三个不变：（得到的是一个唯一的解法）</p><p>1-近平面n 不发生变化</p><p>2-f面的z坐标 也不发生变化</p><p>3-f面的假设中心点 也不发生变化</p><p><img src="https://pic1.zhimg.com/80/v2-ff94d5c9bc31c2a99875f1d591a521fc_720w.webp"></p><p>《GAMES101 现代计算机图形学入门》</p><p>这里有一个相似三角形，就是 每一个坐标 都给乘一个 n&#x2F;z 的比例</p><p><img src="https://pic3.zhimg.com/80/v2-1a246541eac657ae062b4ba2e0393776_720w.webp"></p><p>可以这么理解 给挤压之后的任意一个点 每个项×一个z 就还是这个点</p><p>其实中间项的unknown 也是n</p><p><img src="https://pic3.zhimg.com/80/v2-44a982060fa57180d961275e90f17936_720w.webp"></p><p>所以 我们就知道 第一个项 经过一个变化矩阵 得到第三个项，就可以求变化矩阵。</p><p><img src="https://pic2.zhimg.com/80/v2-2e06efdbdb6891c234ec4d8704d94ee9_720w.webp"></p><p><img src="https://pic4.zhimg.com/80/v2-865e0bc18a1499d117f69cd38268ff67_720w.webp"></p><p>这样就可以解出 四行中的三行</p><p>我们就去找两个z不变的平面；</p><p>但是 z是不变的！近平面的是 x y n 1 远的平面是 x’ y’ z 1</p><p>这两个条件可以求第三行</p><p><img src="https://pic4.zhimg.com/80/v2-f9c7a5672e24de5746e9d2f01b4c5227_720w.webp"></p><p><img src="https://pic4.zhimg.com/80/v2-80c09b9ec689d6f9157c3c7bb8c3baeb_720w.webp"></p><p>接下来就来推导第三行：</p><p>先看近平面：</p><p><img src="https://pic2.zhimg.com/80/v2-90556176bbaf3b4d288427f20a269bb5_720w.webp"></p><p>《GAMES101 现代计算机图形学入门》</p><p>再看远平面；</p><p><img src="https://pic4.zhimg.com/80/v2-c0f740473ba9012d943b42cbd2df39d7_720w.webp"></p><p><img src="https://pic3.zhimg.com/80/v2-20a242eea8759d82e95e234970526002_720w.webp"></p><p><strong>summary：</strong></p><p>这样！ 怎么推导第三行呢</p><p><em><strong>Step01</strong></em></p><p><img src="https://pic2.zhimg.com/80/v2-4586abc2b80b3d832aa0985810393125_720w.webp"></p><p><em><strong>Step02</strong></em></p><p><img src="https://pic2.zhimg.com/80/v2-fda346987ef26acbd01795086fe9762d_720w.webp"></p><p><em><strong>step03</strong></em></p><p>解方程组 得到AB</p><p><img src="https://pic4.zhimg.com/80/v2-c44c19e17ab31582ad6f1794f206011b_720w.webp"></p><p>接下来一步就是正交投影就好了！</p><p>这个就是屏幕空间；</p><h2 id="6-切线空间-Tangent-Space"><a href="#6-切线空间-Tangent-Space" class="headerlink" title="6-切线空间(Tangent Space)"></a><strong>6-切线空间(Tangent Space)</strong></h2><p>对于模型的每个顶点，它都有一个属于自己的切线空间，这个切线空间的原点就是该顶点本身，而z轴是顶点的法线方向（n）, x轴是顶点的切线方向（t），而y轴可由法线和切线叉积而得，也被称为是副切线（bitangent, b）或<strong>副法线</strong>。使用切线空间可以重用法线纹理，所以应用很广。</p><p><img src="https://pic2.zhimg.com/80/v2-889738b69d147f4c6fec3b8c21afb731_720w.webp"></p><p>T为u方向，N为u和v的叉乘，B为N和T的叉乘–谈谈法线贴图 - 可可西 - 博客园</p><p>其中，原点对应顶点坐标，<strong>x轴是切线方向（T），y轴是副切线方向（B），z轴是法线方向（N）</strong></p><p><img src="https://pic2.zhimg.com/80/v2-843e72e12250d37916fd1037985943ad_720w.webp"></p>]]>
    </content>
    <id>http://example.com/2026/02/22/%E5%87%A0%E7%A7%8D%E5%9F%BA%E7%A1%80%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4/</id>
    <link href="http://example.com/2026/02/22/%E5%87%A0%E7%A7%8D%E5%9F%BA%E7%A1%80%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4/"/>
    <published>2026-02-22T14:22:10.000Z</published>
    <summary>
      <![CDATA[<h2 id="变换矩阵"><a href="#变换矩阵" class="headerlink" title="变换矩阵"></a>变换矩阵</h2><p>模型(Model)、观察(View)、投影(Projection)</p>
<h2 id="坐标空间"><a href="#]]>
    </summary>
    <title>基础坐标空间</title>
    <updated>2026-02-22T14:38:19.959Z</updated>
  </entry>
  <entry>
    <author>
      <name>OnricYF</name>
    </author>
    <category term="杂记" scheme="http://example.com/categories/%E6%9D%82%E8%AE%B0/"/>
    <category term="Others" scheme="http://example.com/tags/Others/"/>
    <content>
      <![CDATA[<h2 id="长音符号：ー"><a href="#长音符号：ー" class="headerlink" title="长音符号：ー"></a>长音符号：<strong>ー</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在日语中，用片假名拼写的 “air” 通常是 **エア**，如果后面带有横线（**ー**），它的意思是 **长音符号**。</span><br><span class="line"></span><br><span class="line">具体解释如下：</span><br><span class="line"></span><br><span class="line">1. **表示长音**：在日语片假名中，横线“ー”用于表示前一个音的拖长。因此，“エア”实际发音是两个音节（e-a），但为了模仿英语“air”中“a”部分的发音长度，有时在书写或特定复合词中会写成“エアー”，将“a”音拖长一拍。</span><br><span class="line">    </span><br><span class="line">2. **发音区别**：</span><br><span class="line">    </span><br><span class="line">    - **エア**：发音接近“e-a”，两个音节之间没有明显的拖长。</span><br><span class="line">        </span><br><span class="line">    - **エアー**：发音接近“e-a-”，即最后一个“a”音要拖长一拍。</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">**总结**：  </span><br><span class="line">如果你看到的单词是 **エアー**，后面的横线是 **长音符号**，用来把尾音拖长，使其更贴近英语的发音感觉。</span><br></pre></td></tr></table></figure>]]>
    </content>
    <id>http://example.com/2026/02/22/%E6%97%A5%E8%AF%AD%E6%9D%82%E8%AE%B0/</id>
    <link href="http://example.com/2026/02/22/%E6%97%A5%E8%AF%AD%E6%9D%82%E8%AE%B0/"/>
    <published>2026-02-22T14:22:10.000Z</published>
    <summary>
      <![CDATA[<h2 id="长音符号：ー"><a href="#长音符号：ー" class="headerlink" title="长音符号：ー"></a>长音符号：<strong>ー</strong></h2><figure class="highlight plaintext"><tab]]>
    </summary>
    <title>日语杂记</title>
    <updated>2026-02-24T14:07:45.249Z</updated>
  </entry>
  <entry>
    <author>
      <name>OnricYF</name>
    </author>
    <content>
      <![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]>
    </content>
    <id>http://example.com/2026/02/22/hello-world/</id>
    <link href="http://example.com/2026/02/22/hello-world/"/>
    <published>2026-02-22T11:58:51.978Z</published>
    <summary>
      <![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for]]>
    </summary>
    <title>Hello World</title>
    <updated>2026-02-23T03:48:36.192Z</updated>
  </entry>
</feed>
